// Modified version: reads one wrench file and uses R from CSV
//Most functions and pieces of code were generated by ChatGPT


#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <Eigen/Dense>
#include "kalman.hpp"


const double mass = 0.483;
const Eigen::RowVector3d rs(0,0,0.0);
const Eigen::Vector3d gw(0,0,-9.81); //Gravity vector


// Skew symmetric matrix
Eigen::Matrix3d skew(const Eigen::Vector3d &v) {
    Eigen::Matrix3d S;
    S <<     0, -v.z(),  v.y(),
            v.z(),     0, -v.x(),
            -v.y(),  v.x(),     0;
    return S;
}

Eigen::Matrix3d Ry(double theta) {
    Eigen::Matrix3d R;
    double c = std::cos(theta);
    double s = std::sin(theta);
    R <<  c, 0, s,
            0, 1, 0,
            -s, 0, c;
    return R;
}

Eigen::Matrix3d compute_Rws(double q1, double q2) {
    Eigen::Matrix3d R_offset;
    R_offset << 0, 1, 0,
            0, 0, 1,
            1, 0, 0;

    Eigen::Matrix3d R1 = Ry(q1); // shoulder pitch
    Eigen::Matrix3d R2 = Ry(q2); // wrist pitch (if wrist is also pitch)
    return R1 * R2 * R_offset;
}

Eigen::Vector3d compute_zg(double q1, double q2) {
    Eigen::Matrix3d Rws = compute_Rws(q1, q2);
    return Rws.transpose() * gw;
}

struct wrench_data {
    long long time;     // original (microseconds)
    double time_norm;   // normalized (seconds)
    double fx, fy, fz;
    double tx, ty, tz;
};

struct joint_data {
    long long time;     // original (seconds truncated)
    double time_norm;   // normalized (seconds)
    double angle;
};

bool open_csv(const std::string& filename, std::ifstream& file) {
    file.open(filename);
    return file.is_open();
}

std::vector<wrench_data> read_wrench_file(const std::string& filename) {
    std::vector<wrench_data> data;

    std::ifstream file;
    if (!open_csv(filename, file)) {
        std::cerr << "Error opening wrench file: " << filename << "\n";
        return data;
    }

    std::string line;
    bool first_line = true;

    while (std::getline(file, line)) {
        if (first_line) { first_line = false; continue; }

        std::stringstream ss(line);
        wrench_data row;
        std::string cell;

        std::getline(ss, cell, ','); row.time = std::stoll(cell);
        std::getline(ss, cell, ','); row.fx = std::stod(cell);
        std::getline(ss, cell, ','); row.fy = std::stod(cell);
        std::getline(ss, cell, ','); row.fz = std::stod(cell);
        std::getline(ss, cell, ','); row.tx = std::stod(cell);
        std::getline(ss, cell, ','); row.ty = std::stod(cell);
        std::getline(ss, cell, ','); row.tz = std::stod(cell);

        data.push_back(row);
    }

    return data;
}

std::vector<joint_data> read_joint_file(const std::string& filename) {
    std::vector<joint_data> data;

    std::ifstream file;
    if (!open_csv(filename, file)) {
        std::cerr << "Error opening joint file: " << filename << "\n";
        return data;
    }

    std::string line;
    bool first_line = true;

    while (std::getline(file, line)) {
        if (first_line) {
            first_line = false;
            continue;   // skip header
        }

        std::stringstream ss(line);
        joint_data row;
        std::string cell;

        // Column order:
        // Unix Epoch Time, PWM %, PWM, Angle, Velocity

        // Time (as double → long long)
        std::getline(ss, cell, ',');
        row.time = static_cast<long long>(std::stod(cell));

        // Skip PWM %
        std::getline(ss, cell, ',');

        // Skip PWM
        std::getline(ss, cell, ',');

        // Angle
        std::getline(ss, cell, ',');
        row.angle = std::stod(cell);

        // Done (Velocity is ignored)

        data.push_back(row);
    }

    return data;
}


Eigen::MatrixXd load_R_matrix(const std::string& filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Failed to open R matrix file: " << filename << "\n";
        return Eigen::MatrixXd::Zero(6,6);
    }

    std::string line;
    std::vector<double> values;
    int rows = 0;

    while (std::getline(file, line)) {
        std::stringstream ss(line);
        std::string cell;
        while (std::getline(ss, cell, ',')) {
            values.push_back(std::stod(cell));
        }
        rows++;
    }

    int cols = values.size() / rows;
    Eigen::MatrixXd R(rows, cols);

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            R(i,j) = values[i * cols + j];

    return R;
}

struct kf_entry { long long time; Eigen::VectorXd x_hat; Eigen::Vector3d compensated_force;Eigen::Vector3d compensated_torque;};

void save_kf_csv(const std::string& filename, const std::vector<kf_entry>& kf_data) {
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Failed to open file: " << filename << "\n";
        return;
    }

    // Header: time, 9 state values, 6 compensated outputs
    file << "time,a_x,a_y,a_z,F_x,F_y,F_z,T_x,T_y,T_z,z_1,z_2,z_3,z_4,z_5,z_6\n";

    for (const auto& entry : kf_data) {
        file << entry.time; // time first

        // write 9 state values (x_hat is 9x1)
        const Eigen::VectorXd& x = entry.x_hat;
        for (int i = 0; i < x.size(); ++i) {
            file << "," << x(i);
        }

        // compensated_force is Eigen::Vector3d
        const Eigen::Vector3d& Zf = entry.compensated_force;
        for (int i = 0; i < 3; ++i) {
            file << "," << Zf(i);
        }

        // compensated_torque is Eigen::Vector3d
        const Eigen::Vector3d& Zt = entry.compensated_torque;
        for (int i = 0; i < 3; ++i) {
            file << "," << Zt(i);
        }

        file << "\n";
    }
}

double find_closest_angle(double t, const std::vector<joint_data>& joints)
{
    double best_dt = std::numeric_limits<double>::max();
    double best_angle = 0.0;

    for (const auto& j : joints) {
        double dt = std::abs(j.time_norm - t);
        if (dt < best_dt) {
            best_dt = dt;
            best_angle = j.angle;
        }
    }

    return best_angle;
}

double M_PI = 3.1415;

// Tuning factors
double q_scale = 0.000000001;   // process noise scale
double r_scale_gravity = 8;  // gravity measurement
double r_scale_ftf = 0.05;      // FTS measurement
double p_scale = 1.0;




int main() {
    std::string wrench_file = "Data_collection/variances/output_wrench_log_test2.csv";
    std::string R_file = "Data_collection/R/R_matrix.csv";

    std::string angle_file = "Joint_data/tf_test_24_11_nr_1.csv";

    auto wrench_data_vec = read_wrench_file(wrench_file);

    auto joint_data_vec = read_joint_file(angle_file);

    if (wrench_data_vec.empty()) {
        std::cerr << "No wrench data loaded." << std::endl;
        return 1;
    }

    // =============================
// Time normalization
// =============================

// Convert wrench time (µs → seconds)
    std::vector<double> wrench_times_sec;
    wrench_times_sec.reserve(wrench_data_vec.size());
    for (auto& w : wrench_data_vec) {
        double t_sec = static_cast<double>(w.time) / 1e6;
        wrench_times_sec.push_back(t_sec);
    }

// Convert joint time (already seconds but stored as long long)
    std::vector<double> joint_times_sec;
    joint_times_sec.reserve(joint_data_vec.size());
    for (auto& j : joint_data_vec) {
        joint_times_sec.push_back(static_cast<double>(j.time));
    }

// Find global earliest time
    double t_min = std::numeric_limits<double>::max();

    for (double t : wrench_times_sec) t_min = std::min(t_min, t);
    for (double t : joint_times_sec)   t_min = std::min(t_min, t);

// Normalize both datasets
    for (size_t i = 0; i < wrench_data_vec.size(); i++) {
        wrench_data_vec[i].time_norm = wrench_times_sec[i] - t_min;
    }

    for (size_t i = 0; i < joint_data_vec.size(); i++) {
        joint_data_vec[i].time_norm = joint_times_sec[i] - t_min;
    }

    std::cout << "Time normalized. Global start time = " << t_min << " sec\n";


    Eigen::MatrixXd R6 = load_R_matrix(R_file);
    if (R6.rows() != 6 || R6.cols() != 6) {
        std::cerr << "Invalid R matrix shape. Expected 6x6." << std::endl;
        return 1;
    }

    // ===== Kalman Filter setup =====
    Eigen::MatrixXd A = Eigen::MatrixXd::Identity(9,9);

    Eigen::MatrixXd B(9,3); B.setZero();
    B.block<3,3>(0,0) = Eigen::Matrix3d::Identity();
    B.block<3,3>(3,0) = mass * Eigen::Matrix3d::Identity();
    B.block<3,3>(6,0) = mass * skew(rs);

    Eigen::MatrixXd P = Eigen::MatrixXd::Zero(9,9);
    P.block<3,3>(0,0) = 0.1*Eigen::Matrix3d::Identity();  // gravity
    P.block<3,3>(3,3) = 1.0*Eigen::Matrix3d::Identity();  // force
    P.block<3,3>(6,6) = 1.0*Eigen::Matrix3d::Identity();  // torque

// Optional: scale to tune how confident you are in initial state

    P *= p_scale;


    // FTS measurement
    Eigen::MatrixXd Hf = Eigen::MatrixXd::Zero(9,9);
    Hf.block<3,3>(0,0) = Eigen::Matrix3d::Identity();  // gravity
    Hf.block<3,3>(3,3) = Eigen::Matrix3d::Identity();  // forces
    Hf.block<3,3>(6,6) = Eigen::Matrix3d::Identity();  // torques

// Create a 9x9 R matrix
    Eigen::MatrixXd R = Eigen::MatrixXd::Zero(9,9);


// Gravity block
    R.block<3,3>(0,0) = 0.01*Eigen::Matrix3d::Identity(); // trust zg more


// FTS forces
    R.block<3,3>(3,3) = R6.block<3,3>(0,0) * r_scale_ftf;

// FTS torques
    R.block<3,3>(6,6) = R6.block<3,3>(3,3) * r_scale_ftf;

    Eigen::MatrixXd Q = Eigen::MatrixXd::Identity(9,9) * q_scale;
    Q.block<3,3>(0,0) *= 1.0; //gravity
    Q.block<3,3>(3,3) *= 10.0; //Forces
    Q.block<3,3>(6,6) *= 0.5; // torques
    Q.block<1,1>(7,7) *= 0.3; // torques



    kalman_filter KF(0,A,B,Q,R,Hf,P);
    Eigen::VectorXd x0 = Eigen::VectorXd::Zero(9);

    x0 << 0,0,-9.81,wrench_data_vec[0].fx, wrench_data_vec[0].fy, wrench_data_vec[0].fz,
            wrench_data_vec[0].tx, wrench_data_vec[0].ty, wrench_data_vec[0].tz;

    KF.init(0, x0);

    std::vector<kf_entry> results;

    double prev_time = wrench_data_vec[0].time_norm;

    // after normalization
    std::cout << "First wrench time_norm: " << wrench_data_vec.front().time_norm
              << "  first joint time_norm: " << joint_data_vec.front().time_norm << "\n";

    Eigen::Matrix<double, 6, 9> Zbc;

// Top row:  [ -mb*I   ,   I    ,   0 ]
    Zbc.block<3,3>(0,0) = -mass * Eigen::Matrix3d::Identity();
    Zbc.block<3,3>(0,3) = Eigen::Matrix3d::Identity();
    Zbc.block<3,3>(0,6) = Eigen::Matrix3d::Zero();

// Bottom row: [ -mb*[rbs]× ,   0   ,   I ]
    Zbc.block<3,3>(3,0) = -mass * skew(rs);
    Zbc.block<3,3>(3,3) = Eigen::Matrix3d::Zero();
    Zbc.block<3,3>(3,6) = Eigen::Matrix3d::Identity();




    for (const auto& w : wrench_data_vec) {
        double dt = w.time_norm - prev_time;
        prev_time = w.time_norm;



        KF.predict(Eigen::VectorXd::Zero(9));

        // Compute gravity vector in sensor frame
    // Find nearest joint angle for the current wrench timestamp
        double q1_deg = find_closest_angle(w.time_norm, joint_data_vec);

    // Convert degrees → radians
        double q1 = q1_deg * M_PI / 180.0;

    // Elbow is unknown → keep as zero
        double q2 = 0.0;

        Eigen::Vector3d zg = compute_zg(q1, q2);

        // Build measurement vector
        Eigen::VectorXd z(9);
        z << zg(0), zg(1), zg(2),  // gravity acceleration
                w.fx, w.fy, w.fz,     // FTS forces
                w.tx, w.ty, w.tz;     // FTS torques

        KF.update(z, Hf, R);

        Eigen::Matrix<double,6,1> zbc = Zbc * KF.getXHat();

        Eigen::Vector3d compensated_force =  zbc.segment<3>(0);
        Eigen::Vector3d compensated_torque = zbc.segment<3>(3);

        results.push_back({w.time, KF.getXHat(),compensated_force,compensated_torque});
    }

    save_kf_csv("Data_collection/filtered/Filtered_wrench_output_test1.csv", results);
    std::cout << "Data_collection/filtered/Filtered_wrench_output_test1.csv\n";

    return 0;
}
